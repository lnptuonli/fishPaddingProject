# å›¾è®ºä¸æ ‘æ•°æ®ç»“æ„å®Œå…¨æŒ‡å—

> ä»é›¶å¼€å§‹ï¼Œç³»ç»Ÿå­¦ä¹ å›¾è®ºå’Œæ ‘çš„æ•°æ®ç»“æ„
> 
> é€‚åˆç®—æ³•å­¦ä¹ è€…ï¼ŒåŒ…å«å¤§é‡å¯è§†åŒ–å›¾è¡¨å’Œä»£ç ç¤ºä¾‹

---

## ğŸ“š ç›®å½•

1. [åŸºç¡€æ¦‚å¿µ](#åŸºç¡€æ¦‚å¿µ)
2. [æ ‘ï¼ˆTreeï¼‰](#æ ‘tree)
3. [å›¾ï¼ˆGraphï¼‰](#å›¾graph)
4. [å¹¶æŸ¥é›†ï¼ˆUnion-Findï¼‰](#å¹¶æŸ¥é›†union-find)
5. [å¸¸è§ç®—æ³•](#å¸¸è§ç®—æ³•)
6. [å®æˆ˜åº”ç”¨](#å®æˆ˜åº”ç”¨)

---

## åŸºç¡€æ¦‚å¿µ

### ä»€ä¹ˆæ˜¯å›¾ï¼Ÿä»€ä¹ˆæ˜¯æ ‘ï¼Ÿ

```mermaid
graph TB
    subgraph "æ ‘ Tree"
        A1[æ ¹èŠ‚ç‚¹] --> B1[å­èŠ‚ç‚¹1]
        A1 --> B2[å­èŠ‚ç‚¹2]
        B1 --> C1[å¶å­èŠ‚ç‚¹1]
        B1 --> C2[å¶å­èŠ‚ç‚¹2]
        B2 --> C3[å¶å­èŠ‚ç‚¹3]
    end
    
    subgraph "å›¾ Graph"
        D1((1)) --- D2((2))
        D2 --- D3((3))
        D3 --- D4((4))
        D4 --- D1
        D2 --- D4
    end
```

**æ ¸å¿ƒåŒºåˆ«**ï¼š
- **æ ‘**ï¼šç‰¹æ®Šçš„å›¾ï¼Œæ— ç¯ï¼Œæœ‰æ˜ç¡®çš„çˆ¶å­å…³ç³»
- **å›¾**ï¼šæ›´é€šç”¨ï¼Œå¯ä»¥æœ‰ç¯ï¼ŒèŠ‚ç‚¹ä¹‹é—´å…³ç³»æ›´çµæ´»

---

## æ ‘ï¼ˆTreeï¼‰

### 1. æ ‘çš„åŸºæœ¬æ¦‚å¿µ

```mermaid
graph TB
    A[æ ¹èŠ‚ç‚¹ Root<br/>æ·±åº¦=0] --> B[èŠ‚ç‚¹B<br/>æ·±åº¦=1]
    A --> C[èŠ‚ç‚¹C<br/>æ·±åº¦=1]
    B --> D[èŠ‚ç‚¹D<br/>æ·±åº¦=2]
    B --> E[èŠ‚ç‚¹E<br/>æ·±åº¦=2]
    C --> F[èŠ‚ç‚¹F<br/>æ·±åº¦=2]
    
    style A fill:#ff6b6b
    style D fill:#51cf66
    style E fill:#51cf66
    style F fill:#51cf66
```

**æœ¯è¯­è§£é‡Š**ï¼š

| æœ¯è¯­ | å®šä¹‰ | ç¤ºä¾‹ |
|------|------|------|
| **æ ¹èŠ‚ç‚¹** | æ ‘çš„é¡¶ç«¯èŠ‚ç‚¹ï¼Œæ²¡æœ‰çˆ¶èŠ‚ç‚¹ | èŠ‚ç‚¹A |
| **å¶å­èŠ‚ç‚¹** | æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ | èŠ‚ç‚¹Dã€Eã€F |
| **çˆ¶èŠ‚ç‚¹** | æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ | Aæ˜¯Bçš„çˆ¶èŠ‚ç‚¹ |
| **å­èŠ‚ç‚¹** | æŸèŠ‚ç‚¹çš„ç›´æ¥ä¸‹çº§ | Bã€Cæ˜¯Açš„å­èŠ‚ç‚¹ |
| **å…„å¼ŸèŠ‚ç‚¹** | åŒä¸€çˆ¶èŠ‚ç‚¹çš„èŠ‚ç‚¹ | Bå’ŒCæ˜¯å…„å¼Ÿ |
| **æ·±åº¦** | ä»æ ¹èŠ‚ç‚¹åˆ°è¯¥èŠ‚ç‚¹çš„è¾¹æ•° | Dçš„æ·±åº¦æ˜¯2 |
| **é«˜åº¦** | ä»è¯¥èŠ‚ç‚¹åˆ°æœ€æ·±å¶å­çš„è¾¹æ•° | Açš„é«˜åº¦æ˜¯2 |
| **å­æ ‘** | æŸèŠ‚ç‚¹åŠå…¶æ‰€æœ‰åä»£ | BåŠå…¶å­èŠ‚ç‚¹æ„æˆå­æ ‘ |

### 2. äºŒå‰æ ‘ï¼ˆBinary Treeï¼‰

æ¯ä¸ªèŠ‚ç‚¹**æœ€å¤šæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹**çš„æ ‘ã€‚

```mermaid
graph TB
    A[1] --> B[2]
    A --> C[3]
    B --> D[4]
    B --> E[5]
    C --> F[6]
    C --> G[7]
    
    style A fill:#339af0
    style B fill:#339af0
    style C fill:#339af0
    style D fill:#51cf66
    style E fill:#51cf66
    style F fill:#51cf66
    style G fill:#51cf66
```

#### Javaå®ç°

```java
/**
 * äºŒå‰æ ‘èŠ‚ç‚¹å®šä¹‰
 */
class TreeNode {
    int val;           // èŠ‚ç‚¹å€¼
    TreeNode left;     // å·¦å­èŠ‚ç‚¹
    TreeNode right;    // å³å­èŠ‚ç‚¹
    
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

/**
 * åˆ›å»ºäºŒå‰æ ‘
 */
public class BinaryTreeExample {
    public static void main(String[] args) {
        // åˆ›å»ºä¸Šå›¾çš„äºŒå‰æ ‘
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right.left = new TreeNode(6);
        root.right.right = new TreeNode(7);
    }
}
```

### 3. äºŒå‰æ ‘çš„éå†

#### å‰åºéå†ï¼ˆPre-orderï¼‰ï¼šæ ¹ â†’ å·¦ â†’ å³

```mermaid
graph TB
    A[1<br/>â‘ è®¿é—®] --> B[2<br/>â‘¡è®¿é—®]
    A --> C[3<br/>â‘¤è®¿é—®]
    B --> D[4<br/>â‘¢è®¿é—®]
    B --> E[5<br/>â‘£è®¿é—®]
    C --> F[6<br/>â‘¥è®¿é—®]
    C --> G[7<br/>â‘¦è®¿é—®]
    
    style A fill:#ff6b6b
    style B fill:#ff6b6b
    style C fill:#ff6b6b
```

**éå†é¡ºåº**ï¼š1 â†’ 2 â†’ 4 â†’ 5 â†’ 3 â†’ 6 â†’ 7

```java
/**
 * å‰åºéå†ï¼ˆé€’å½’ï¼‰
 */
void preOrder(TreeNode root) {
    if (root == null) return;
    
    System.out.print(root.val + " ");  // è®¿é—®æ ¹èŠ‚ç‚¹
    preOrder(root.left);               // éå†å·¦å­æ ‘
    preOrder(root.right);              // éå†å³å­æ ‘
}
```

#### ä¸­åºéå†ï¼ˆIn-orderï¼‰ï¼šå·¦ â†’ æ ¹ â†’ å³

```mermaid
graph TB
    A[1<br/>â‘£è®¿é—®] --> B[2<br/>â‘¡è®¿é—®]
    A --> C[3<br/>â‘¥è®¿é—®]
    B --> D[4<br/>â‘ è®¿é—®]
    B --> E[5<br/>â‘¢è®¿é—®]
    C --> F[6<br/>â‘¤è®¿é—®]
    C --> G[7<br/>â‘¦è®¿é—®]
    
    style D fill:#51cf66
    style E fill:#51cf66
    style F fill:#51cf66
    style G fill:#51cf66
```

**éå†é¡ºåº**ï¼š4 â†’ 2 â†’ 5 â†’ 1 â†’ 6 â†’ 3 â†’ 7

```java
/**
 * ä¸­åºéå†ï¼ˆé€’å½’ï¼‰
 */
void inOrder(TreeNode root) {
    if (root == null) return;
    
    inOrder(root.left);                // éå†å·¦å­æ ‘
    System.out.print(root.val + " ");  // è®¿é—®æ ¹èŠ‚ç‚¹
    inOrder(root.right);               // éå†å³å­æ ‘
}
```

#### ååºéå†ï¼ˆPost-orderï¼‰ï¼šå·¦ â†’ å³ â†’ æ ¹

```mermaid
graph TB
    A[1<br/>â‘¦è®¿é—®] --> B[2<br/>â‘¢è®¿é—®]
    A --> C[3<br/>â‘¥è®¿é—®]
    B --> D[4<br/>â‘ è®¿é—®]
    B --> E[5<br/>â‘¡è®¿é—®]
    C --> F[6<br/>â‘£è®¿é—®]
    C --> G[7<br/>â‘¤è®¿é—®]
    
    style A fill:#ffd43b
```

**éå†é¡ºåº**ï¼š4 â†’ 5 â†’ 2 â†’ 6 â†’ 7 â†’ 3 â†’ 1

```java
/**
 * ååºéå†ï¼ˆé€’å½’ï¼‰
 */
void postOrder(TreeNode root) {
    if (root == null) return;
    
    postOrder(root.left);              // éå†å·¦å­æ ‘
    postOrder(root.right);             // éå†å³å­æ ‘
    System.out.print(root.val + " ");  // è®¿é—®æ ¹èŠ‚ç‚¹
}
```

#### å±‚åºéå†ï¼ˆLevel-orderï¼‰ï¼šä¸€å±‚ä¸€å±‚éå†

```mermaid
graph TB
    A[1<br/>ç¬¬0å±‚] --> B[2<br/>ç¬¬1å±‚]
    A --> C[3<br/>ç¬¬1å±‚]
    B --> D[4<br/>ç¬¬2å±‚]
    B --> E[5<br/>ç¬¬2å±‚]
    C --> F[6<br/>ç¬¬2å±‚]
    C --> G[7<br/>ç¬¬2å±‚]
    
    style A fill:#ff6b6b
    style B fill:#339af0
    style C fill:#339af0
    style D fill:#51cf66
    style E fill:#51cf66
    style F fill:#51cf66
    style G fill:#51cf66
```

**éå†é¡ºåº**ï¼š1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6 â†’ 7

```java
/**
 * å±‚åºéå†ï¼ˆä½¿ç”¨é˜Ÿåˆ—ï¼‰
 */
void levelOrder(TreeNode root) {
    if (root == null) return;
    
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        System.out.print(node.val + " ");
        
        if (node.left != null) queue.offer(node.left);
        if (node.right != null) queue.offer(node.right);
    }
}
```

### 4. ç‰¹æ®Šçš„äºŒå‰æ ‘

#### å®Œå…¨äºŒå‰æ ‘ï¼ˆComplete Binary Treeï¼‰

é™¤äº†æœ€åä¸€å±‚ï¼Œå…¶ä»–å±‚éƒ½æ˜¯æ»¡çš„ï¼Œæœ€åä¸€å±‚ä»å·¦åˆ°å³å¡«å……ã€‚

```mermaid
graph TB
    A[1] --> B[2]
    A --> C[3]
    B --> D[4]
    B --> E[5]
    C --> F[6]
    
    style A fill:#51cf66
    style B fill:#51cf66
    style C fill:#51cf66
    style D fill:#51cf66
    style E fill:#51cf66
    style F fill:#51cf66
```

**ç‰¹ç‚¹**ï¼š
- âœ… å¯ä»¥ç”¨æ•°ç»„é«˜æ•ˆå­˜å‚¨
- âœ… çˆ¶èŠ‚ç‚¹ i çš„å·¦å­èŠ‚ç‚¹ï¼š2i+1ï¼Œå³å­èŠ‚ç‚¹ï¼š2i+2
- âœ… å †ï¼ˆHeapï¼‰å°±æ˜¯å®Œå…¨äºŒå‰æ ‘

#### æ»¡äºŒå‰æ ‘ï¼ˆFull Binary Treeï¼‰

æ‰€æœ‰å±‚éƒ½æ˜¯æ»¡çš„ã€‚

```mermaid
graph TB
    A[1] --> B[2]
    A --> C[3]
    B --> D[4]
    B --> E[5]
    C --> F[6]
    C --> G[7]
    
    style A fill:#ff6b6b
    style B fill:#ff6b6b
    style C fill:#ff6b6b
    style D fill:#ff6b6b
    style E fill:#ff6b6b
    style F fill:#ff6b6b
    style G fill:#ff6b6b
```

**ç‰¹ç‚¹**ï¼š
- èŠ‚ç‚¹æ•° = 2^h - 1ï¼ˆhæ˜¯é«˜åº¦ï¼‰
- ç¬¬ i å±‚æœ‰ 2^(i-1) ä¸ªèŠ‚ç‚¹

#### äºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Tree, BSTï¼‰

å·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹ < æ ¹èŠ‚ç‚¹ < å³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹

```mermaid
graph TB
    A[5] --> B[3]
    A --> C[8]
    B --> D[1]
    B --> E[4]
    C --> F[7]
    C --> G[9]
    
    style A fill:#339af0
    style B fill:#51cf66
    style C fill:#ff6b6b
```

**ç‰¹ç‚¹**ï¼š
- âœ… ä¸­åºéå†ç»“æœæ˜¯æœ‰åºçš„ï¼š1 â†’ 3 â†’ 4 â†’ 5 â†’ 7 â†’ 8 â†’ 9
- âœ… æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤ï¼šå¹³å‡ O(log n)

```java
/**
 * åœ¨BSTä¸­æŸ¥æ‰¾å€¼
 */
TreeNode search(TreeNode root, int target) {
    if (root == null || root.val == target) {
        return root;
    }
    
    if (target < root.val) {
        return search(root.left, target);   // å»å·¦å­æ ‘æ‰¾
    } else {
        return search(root.right, target);  // å»å³å­æ ‘æ‰¾
    }
}
```

---

## å›¾ï¼ˆGraphï¼‰

### 1. å›¾çš„åŸºæœ¬æ¦‚å¿µ

å›¾ç”±**èŠ‚ç‚¹ï¼ˆé¡¶ç‚¹ï¼‰**å’Œ**è¾¹**ç»„æˆã€‚

```mermaid
graph LR
    A((A)) --- B((B))
    B --- C((C))
    C --- D((D))
    D --- A
    B --- D
    
    style A fill:#ff6b6b
    style B fill:#339af0
    style C fill:#51cf66
    style D fill:#ffd43b
```

**æœ¯è¯­è§£é‡Š**ï¼š

| æœ¯è¯­ | å®šä¹‰ | ç¤ºä¾‹ |
|------|------|------|
| **é¡¶ç‚¹/èŠ‚ç‚¹** | å›¾ä¸­çš„ç‚¹ | Aã€Bã€Cã€D |
| **è¾¹** | è¿æ¥ä¸¤ä¸ªé¡¶ç‚¹çš„çº¿ | A-Bã€B-Cç­‰ |
| **åº¦** | ä¸è¯¥é¡¶ç‚¹ç›¸è¿çš„è¾¹æ•° | Açš„åº¦æ˜¯2 |
| **è·¯å¾„** | ä»ä¸€ä¸ªé¡¶ç‚¹åˆ°å¦ä¸€ä¸ªé¡¶ç‚¹çš„é¡¶ç‚¹åºåˆ— | Aâ†’Bâ†’C |
| **ç¯** | èµ·ç‚¹å’Œç»ˆç‚¹ç›¸åŒçš„è·¯å¾„ | Aâ†’Bâ†’Dâ†’A |
| **è¿é€š** | ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´å­˜åœ¨è·¯å¾„ | Aå’ŒCè¿é€š |
| **è¿é€šå›¾** | ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹éƒ½è¿é€š | ä¸Šå›¾æ˜¯è¿é€šå›¾ |

### 2. å›¾çš„åˆ†ç±»

#### æ— å‘å›¾ vs æœ‰å‘å›¾

```mermaid
graph TB
    subgraph "æ— å‘å›¾ Undirected"
        A1((1)) --- B1((2))
        B1 --- C1((3))
        C1 --- A1
    end
    
    subgraph "æœ‰å‘å›¾ Directed"
        A2((1)) --> B2((2))
        B2 --> C2((3))
        C2 --> A2
    end
```

**åŒºåˆ«**ï¼š
- **æ— å‘å›¾**ï¼šè¾¹æ²¡æœ‰æ–¹å‘ï¼ŒA-B ç­‰ä»·äº B-A
- **æœ‰å‘å›¾**ï¼šè¾¹æœ‰æ–¹å‘ï¼ŒAâ†’B ä¸ç­‰äº Bâ†’A

#### å¸¦æƒå›¾ vs æ— æƒå›¾

```mermaid
graph LR
    subgraph "æ— æƒå›¾"
        A1((A)) --- B1((B))
        B1 --- C1((C))
    end
    
    subgraph "å¸¦æƒå›¾"
        A2((A)) ---|5| B2((B))
        B2 ---|3| C2((C))
        C2 ---|7| A2
    end
```

**åŒºåˆ«**ï¼š
- **æ— æƒå›¾**ï¼šè¾¹æ²¡æœ‰æƒé‡ï¼Œæ‰€æœ‰è¾¹"ä»£ä»·"ç›¸åŒ
- **å¸¦æƒå›¾**ï¼šè¾¹æœ‰æƒé‡ï¼Œè¡¨ç¤ºè·ç¦»ã€æˆæœ¬ç­‰

### 3. å›¾çš„å­˜å‚¨æ–¹å¼

#### é‚»æ¥çŸ©é˜µï¼ˆAdjacency Matrixï¼‰

ç”¨äºŒç»´æ•°ç»„å­˜å‚¨å›¾ã€‚

```mermaid
graph LR
    A((0)) --- B((1))
    B --- C((2))
    C --- A
    
    style A fill:#ff6b6b
    style B fill:#339af0
    style C fill:#51cf66
```

**é‚»æ¥çŸ©é˜µ**ï¼š

|   | 0 | 1 | 2 |
|---|---|---|---|
| **0** | 0 | 1 | 1 |
| **1** | 1 | 0 | 1 |
| **2** | 1 | 1 | 0 |

```java
/**
 * é‚»æ¥çŸ©é˜µè¡¨ç¤ºæ³•
 */
class GraphMatrix {
    int[][] matrix;  // matrix[i][j] = 1 è¡¨ç¤º i å’Œ j æœ‰è¾¹
    int n;           // é¡¶ç‚¹æ•°é‡
    
    public GraphMatrix(int n) {
        this.n = n;
        this.matrix = new int[n][n];
    }
    
    // æ·»åŠ è¾¹
    public void addEdge(int u, int v) {
        matrix[u][v] = 1;
        matrix[v][u] = 1;  // æ— å‘å›¾
    }
    
    // åˆ¤æ–­æ˜¯å¦æœ‰è¾¹
    public boolean hasEdge(int u, int v) {
        return matrix[u][v] == 1;
    }
}
```

**ä¼˜ç¼ºç‚¹**ï¼š
- âœ… æŸ¥è¯¢ä¸¤ç‚¹æ˜¯å¦æœ‰è¾¹ï¼šO(1)
- âœ… é€‚åˆç¨ å¯†å›¾ï¼ˆè¾¹å¾ˆå¤šï¼‰
- âŒ ç©ºé—´å¤æ‚åº¦ï¼šO(nÂ²)
- âŒ éå†æ‰€æœ‰é‚»å±…ï¼šO(n)

#### é‚»æ¥è¡¨ï¼ˆAdjacency Listï¼‰

ç”¨é“¾è¡¨æ•°ç»„å­˜å‚¨å›¾ã€‚

```mermaid
graph LR
    A((0)) --- B((1))
    B --- C((2))
    C --- A
```

**é‚»æ¥è¡¨**ï¼š

```
0: [1, 2]
1: [0, 2]
2: [0, 1]
```

```java
/**
 * é‚»æ¥è¡¨è¡¨ç¤ºæ³•
 */
class GraphList {
    List<List<Integer>> adj;  // adj[i] å­˜å‚¨ä¸ i ç›¸é‚»çš„æ‰€æœ‰é¡¶ç‚¹
    int n;
    
    public GraphList(int n) {
        this.n = n;
        this.adj = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
        }
    }
    
    // æ·»åŠ è¾¹
    public void addEdge(int u, int v) {
        adj.get(u).add(v);
        adj.get(v).add(u);  // æ— å‘å›¾
    }
    
    // è·å–æ‰€æœ‰é‚»å±…
    public List<Integer> getNeighbors(int u) {
        return adj.get(u);
    }
}
```

**ä¼˜ç¼ºç‚¹**ï¼š
- âœ… ç©ºé—´å¤æ‚åº¦ï¼šO(V + E)ï¼ŒVæ˜¯é¡¶ç‚¹æ•°ï¼ŒEæ˜¯è¾¹æ•°
- âœ… é€‚åˆç¨€ç–å›¾ï¼ˆè¾¹è¾ƒå°‘ï¼‰
- âœ… éå†æ‰€æœ‰é‚»å±…ï¼šO(åº¦æ•°)
- âŒ æŸ¥è¯¢ä¸¤ç‚¹æ˜¯å¦æœ‰è¾¹ï¼šO(åº¦æ•°)

### 4. å›¾çš„éå†

#### æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰

**æ ¸å¿ƒæ€æƒ³**ï¼šä¸€æ¡è·¯èµ°åˆ°é»‘ï¼Œèµ°ä¸é€šå†å›å¤´ã€‚

```mermaid
graph TB
    A((1<br/>â‘ )) --> B((2<br/>â‘¡))
    A --> C((3<br/>â‘¤))
    B --> D((4<br/>â‘¢))
    B --> E((5<br/>â‘£))
    C --> F((6<br/>â‘¥))
    
    style A fill:#ff6b6b
    style B fill:#ff6b6b
    style D fill:#ff6b6b
```

**éå†é¡ºåº**ï¼š1 â†’ 2 â†’ 4 â†’ 5 â†’ 3 â†’ 6

```java
/**
 * DFSï¼ˆé€’å½’ç‰ˆï¼‰
 */
void dfs(int u, boolean[] visited, List<List<Integer>> adj) {
    visited[u] = true;
    System.out.print(u + " ");
    
    for (int v : adj.get(u)) {
        if (!visited[v]) {
            dfs(v, visited, adj);
        }
    }
}

/**
 * DFSï¼ˆæ ˆç‰ˆï¼‰
 */
void dfsIterative(int start, List<List<Integer>> adj) {
    boolean[] visited = new boolean[adj.size()];
    Stack<Integer> stack = new Stack<>();
    
    stack.push(start);
    
    while (!stack.isEmpty()) {
        int u = stack.pop();
        
        if (visited[u]) continue;
        visited[u] = true;
        System.out.print(u + " ");
        
        for (int v : adj.get(u)) {
            if (!visited[v]) {
                stack.push(v);
            }
        }
    }
}
```

**DFSæ‰§è¡Œæµç¨‹**ï¼š

```mermaid
graph TB
    Start[å¼€å§‹: è®¿é—®èŠ‚ç‚¹1] --> Visit1[æ ‡è®°1ä¸ºå·²è®¿é—®]
    Visit1 --> Check2{èŠ‚ç‚¹2<br/>æœªè®¿é—®?}
    Check2 -->|æ˜¯| DFS2[é€’å½’è®¿é—®2]
    DFS2 --> Check4{èŠ‚ç‚¹4<br/>æœªè®¿é—®?}
    Check4 -->|æ˜¯| DFS4[é€’å½’è®¿é—®4]
    DFS4 --> Back2[å›åˆ°2]
    Back2 --> Check5{èŠ‚ç‚¹5<br/>æœªè®¿é—®?}
    Check5 -->|æ˜¯| DFS5[é€’å½’è®¿é—®5]
    DFS5 --> Back1[å›åˆ°1]
    Back1 --> Check3{èŠ‚ç‚¹3<br/>æœªè®¿é—®?}
    Check3 -->|æ˜¯| DFS3[é€’å½’è®¿é—®3]
    DFS3 --> End[ç»“æŸ]
    
    style Start fill:#ff6b6b
    style Visit1 fill:#ff6b6b
    style DFS2 fill:#339af0
    style DFS4 fill:#51cf66
    style DFS5 fill:#51cf66
    style DFS3 fill:#ffd43b
```

#### å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰

**æ ¸å¿ƒæ€æƒ³**ï¼šä¸€å±‚ä¸€å±‚æ‰©æ•£ï¼Œåƒæ°´æ³¢çº¹ã€‚

```mermaid
graph TB
    A((1<br/>ç¬¬0å±‚)) --> B((2<br/>ç¬¬1å±‚))
    A --> C((3<br/>ç¬¬1å±‚))
    B --> D((4<br/>ç¬¬2å±‚))
    B --> E((5<br/>ç¬¬2å±‚))
    C --> F((6<br/>ç¬¬2å±‚))
    
    style A fill:#ff6b6b
    style B fill:#339af0
    style C fill:#339af0
    style D fill:#51cf66
    style E fill:#51cf66
    style F fill:#51cf66
```

**éå†é¡ºåº**ï¼š1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6

```java
/**
 * BFSï¼ˆé˜Ÿåˆ—ç‰ˆï¼‰
 */
void bfs(int start, List<List<Integer>> adj) {
    boolean[] visited = new boolean[adj.size()];
    Queue<Integer> queue = new LinkedList<>();
    
    queue.offer(start);
    visited[start] = true;
    
    while (!queue.isEmpty()) {
        int u = queue.poll();
        System.out.print(u + " ");
        
        for (int v : adj.get(u)) {
            if (!visited[v]) {
                visited[v] = true;
                queue.offer(v);
            }
        }
    }
}
```

**BFSæ‰§è¡Œæµç¨‹**ï¼š

```mermaid
graph LR
    Start[é˜Ÿåˆ—: 1] --> Step1[å‡ºé˜Ÿ1, å…¥é˜Ÿ2,3]
    Step1 --> Queue1[é˜Ÿåˆ—: 2,3]
    Queue1 --> Step2[å‡ºé˜Ÿ2, å…¥é˜Ÿ4,5]
    Step2 --> Queue2[é˜Ÿåˆ—: 3,4,5]
    Queue2 --> Step3[å‡ºé˜Ÿ3, å…¥é˜Ÿ6]
    Step3 --> Queue3[é˜Ÿåˆ—: 4,5,6]
    Queue3 --> Step4[å‡ºé˜Ÿ4,5,6]
    Step4 --> End[é˜Ÿåˆ—ä¸ºç©º, ç»“æŸ]
    
    style Start fill:#ff6b6b
    style Queue1 fill:#339af0
    style Queue2 fill:#51cf66
    style Queue3 fill:#ffd43b
```

#### DFS vs BFS å¯¹æ¯”

| ç»´åº¦ | DFS | BFS |
|------|-----|-----|
| **æ•°æ®ç»“æ„** | æ ˆï¼ˆé€’å½’ï¼‰ | é˜Ÿåˆ— |
| **ç©ºé—´å¤æ‚åº¦** | O(h)ï¼Œhæ˜¯æ·±åº¦ | O(w)ï¼Œwæ˜¯æœ€å¤§å®½åº¦ |
| **æ‰¾æœ€çŸ­è·¯å¾„** | âŒ ä¸ä¿è¯ | âœ… ä¿è¯ï¼ˆæ— æƒå›¾ï¼‰ |
| **é€‚ç”¨åœºæ™¯** | è·¯å¾„é—®é¢˜ã€æ‹“æ‰‘æ’åº | æœ€çŸ­è·¯å¾„ã€å±‚æ¬¡éå† |
| **å®ç°éš¾åº¦** | é€’å½’ç®€å• | é˜Ÿåˆ—ç®€å• |

---

## å¹¶æŸ¥é›†ï¼ˆUnion-Findï¼‰

### 1. ä»€ä¹ˆæ˜¯å¹¶æŸ¥é›†ï¼Ÿ

å¹¶æŸ¥é›†æ˜¯ä¸€ç§**æ ‘å½¢æ•°æ®ç»“æ„**ï¼Œç”¨äºå¤„ç†**ä¸ç›¸äº¤é›†åˆ**çš„åˆå¹¶å’ŒæŸ¥è¯¢ã€‚

**æ ¸å¿ƒé—®é¢˜**ï¼š
- åˆ¤æ–­ä¸¤ä¸ªå…ƒç´ æ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆä¸­ï¼Ÿ
- åˆå¹¶ä¸¤ä¸ªé›†åˆ

```mermaid
graph TB
    subgraph "é›†åˆ1"
        A1[1] --> B1[2]
        A1 --> C1[3]
    end
    
    subgraph "é›†åˆ2"
        A2[4] --> B2[5]
    end
    
    subgraph "é›†åˆ3"
        A3[6]
    end
    
    style A1 fill:#ff6b6b
    style A2 fill:#339af0
    style A3 fill:#51cf66
```

### 2. å¹¶æŸ¥é›†çš„åŸºæœ¬æ“ä½œ

#### åˆå§‹åŒ–

```java
class UnionFind {
    int[] parent;  // parent[i] è¡¨ç¤º i çš„çˆ¶èŠ‚ç‚¹
    int[] rank;    // rank[i] è¡¨ç¤ºä»¥ i ä¸ºæ ¹çš„æ ‘çš„æ·±åº¦
    
    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        
        // åˆå§‹æ—¶ï¼Œæ¯ä¸ªå…ƒç´ çš„çˆ¶èŠ‚ç‚¹æ˜¯è‡ªå·±
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 1;
        }
    }
}
```

**åˆå§‹çŠ¶æ€**ï¼š

```mermaid
graph TB
    A[0<br/>parent=0]
    B[1<br/>parent=1]
    C[2<br/>parent=2]
    D[3<br/>parent=3]
    E[4<br/>parent=4]
    
    style A fill:#ff6b6b
    style B fill:#339af0
    style C fill:#51cf66
    style D fill:#ffd43b
    style E fill:#ff8787
```

#### æŸ¥æ‰¾ï¼ˆFindï¼‰- æ‰¾åˆ°æ ¹èŠ‚ç‚¹

```java
/**
 * æŸ¥æ‰¾ x çš„æ ¹èŠ‚ç‚¹ï¼ˆå¸¦è·¯å¾„å‹ç¼©ï¼‰
 */
public int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]);  // è·¯å¾„å‹ç¼©
    }
    return parent[x];
}
```

**è·¯å¾„å‹ç¼©ç¤ºä¾‹**ï¼š

```mermaid
graph TB
    subgraph "å‹ç¼©å‰"
        A1[0] --> B1[1]
        B1 --> C1[2]
        C1 --> D1[3]
    end
    
    subgraph "å‹ç¼©å find3"
        A2[0] --> B2[1]
        A2 --> C2[2]
        A2 --> D2[3]
    end
    
    style A1 fill:#ff6b6b
    style A2 fill:#ff6b6b
```

**ä¸ºä»€ä¹ˆè¦è·¯å¾„å‹ç¼©ï¼Ÿ**
- å‡å°‘æ ‘çš„æ·±åº¦
- åŠ å¿«åç»­æŸ¥æ‰¾é€Ÿåº¦
- æ—¶é—´å¤æ‚åº¦ä» O(n) é™åˆ° O(Î±(n))ï¼ŒÎ±æ˜¯åé˜¿å…‹æ›¼å‡½æ•°ï¼Œå‡ ä¹ä¸ºå¸¸æ•°

#### åˆå¹¶ï¼ˆUnionï¼‰- åˆå¹¶ä¸¤ä¸ªé›†åˆ

```java
/**
 * åˆå¹¶ x å’Œ y æ‰€åœ¨çš„é›†åˆ
 */
public void union(int x, int y) {
    int rootX = find(x);
    int rootY = find(y);
    
    if (rootX == rootY) return;  // å·²ç»åœ¨åŒä¸€é›†åˆ
    
    // æŒ‰ç§©åˆå¹¶ï¼šå°†æ·±åº¦å°çš„æ ‘è¿åˆ°æ·±åº¦å¤§çš„æ ‘ä¸Š
    if (rank[rootX] < rank[rootY]) {
        parent[rootX] = rootY;
    } else if (rank[rootX] > rank[rootY]) {
        parent[rootY] = rootX;
    } else {
        parent[rootY] = rootX;
        rank[rootX]++;
    }
}
```

**åˆå¹¶è¿‡ç¨‹ç¤ºä¾‹**ï¼š

```mermaid
graph TB
    subgraph "åˆå¹¶å‰"
        A1[0] --> B1[1]
        C1[2] --> D1[3]
    end
    
    subgraph "union0,2å"
        A2[0] --> B2[1]
        A2 --> C2[2]
        C2 --> D2[3]
    end
    
    style A1 fill:#ff6b6b
    style C1 fill:#339af0
    style A2 fill:#ff6b6b
```

### 3. å¹¶æŸ¥é›†çš„ä¼˜åŒ–

#### ä¼˜åŒ–1ï¼šè·¯å¾„å‹ç¼©

```java
// é€’å½’ç‰ˆï¼ˆæ¨èï¼‰
public int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]);  // è·¯å¾„å‹ç¼©
    }
    return parent[x];
}

// è¿­ä»£ç‰ˆ
public int findIterative(int x) {
    int root = x;
    // æ‰¾åˆ°æ ¹èŠ‚ç‚¹
    while (parent[root] != root) {
        root = parent[root];
    }
    // è·¯å¾„å‹ç¼©ï¼šå°†è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹ç›´æ¥è¿åˆ°æ ¹èŠ‚ç‚¹
    while (x != root) {
        int next = parent[x];
        parent[x] = root;
        x = next;
    }
    return root;
}
```

#### ä¼˜åŒ–2ï¼šæŒ‰ç§©åˆå¹¶

```java
public void union(int x, int y) {
    int rootX = find(x);
    int rootY = find(y);
    
    if (rootX == rootY) return;
    
    // å°†æ·±åº¦å°çš„æ ‘è¿åˆ°æ·±åº¦å¤§çš„æ ‘ä¸Š
    if (rank[rootX] < rank[rootY]) {
        parent[rootX] = rootY;
    } else if (rank[rootX] > rank[rootY]) {
        parent[rootY] = rootX;
    } else {
        parent[rootY] = rootX;
        rank[rootX]++;  // åªæœ‰æ·±åº¦ç›¸åŒæ—¶æ‰å¢åŠ ç§©
    }
}
```

**ä¸ºä»€ä¹ˆè¦æŒ‰ç§©åˆå¹¶ï¼Ÿ**

```mermaid
graph TB
    subgraph "ä¸æŒ‰ç§©åˆå¹¶ - å¯èƒ½é€€åŒ–æˆé“¾è¡¨"
        A1[0] --> B1[1]
        B1 --> C1[2]
        C1 --> D1[3]
        D1 --> E1[4]
    end
    
    subgraph "æŒ‰ç§©åˆå¹¶ - ä¿æŒå¹³è¡¡"
        A2[0] --> B2[1]
        A2 --> C2[2]
        B2 --> D2[3]
        B2 --> E2[4]
    end
    
    style A1 fill:#ff6b6b
    style A2 fill:#51cf66
```

### 4. å¹¶æŸ¥é›†çš„åº”ç”¨åœºæ™¯

| åº”ç”¨ | è¯´æ˜ | LeetCodeé¢˜ç›® |
|------|------|-------------|
| **è¿é€šæ€§åˆ¤æ–­** | åˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦è¿é€š | 547. çœä»½æ•°é‡ |
| **æœ€å°ç”Ÿæˆæ ‘** | Kruskalç®—æ³• | 1584. è¿æ¥æ‰€æœ‰ç‚¹çš„æœ€å°è´¹ç”¨ |
| **æ£€æµ‹ç¯** | åˆ¤æ–­å›¾ä¸­æ˜¯å¦æœ‰ç¯ | 684. å†—ä½™è¿æ¥ |
| **åŠ¨æ€è¿é€šæ€§** | åŠ¨æ€æ·»åŠ è¾¹ï¼ŒæŸ¥è¯¢è¿é€šæ€§ | 3607. ç”µç½‘ç»´æŠ¤ |
| **æœ‹å‹åœˆé—®é¢˜** | ç¤¾äº¤ç½‘ç»œåˆ†ç»„ | 547. çœä»½æ•°é‡ |

### 5. å®Œæ•´çš„å¹¶æŸ¥é›†æ¨¡æ¿

```java
/**
 * å¹¶æŸ¥é›†å®Œæ•´å®ç°ï¼ˆå¸¦æ‰€æœ‰ä¼˜åŒ–ï¼‰
 */
class UnionFind {
    private int[] parent;  // çˆ¶èŠ‚ç‚¹æ•°ç»„
    private int[] rank;    // ç§©æ•°ç»„
    private int count;     // è¿é€šåˆ†é‡æ•°é‡
    
    /**
     * åˆå§‹åŒ–
     * @param n å…ƒç´ æ•°é‡
     */
    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        count = n;
        
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 1;
        }
    }
    
    /**
     * æŸ¥æ‰¾æ ¹èŠ‚ç‚¹ï¼ˆå¸¦è·¯å¾„å‹ç¼©ï¼‰
     * @param x å…ƒç´ 
     * @return æ ¹èŠ‚ç‚¹
     */
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // è·¯å¾„å‹ç¼©
        }
        return parent[x];
    }
    
    /**
     * åˆå¹¶ä¸¤ä¸ªé›†åˆï¼ˆæŒ‰ç§©åˆå¹¶ï¼‰
     * @param x å…ƒç´ x
     * @param y å…ƒç´ y
     */
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if (rootX == rootY) return;
        
        // æŒ‰ç§©åˆå¹¶
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        
        count--;  // è¿é€šåˆ†é‡å‡1
    }
    
    /**
     * åˆ¤æ–­ä¸¤ä¸ªå…ƒç´ æ˜¯å¦è¿é€š
     * @param x å…ƒç´ x
     * @param y å…ƒç´ y
     * @return æ˜¯å¦è¿é€š
     */
    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }
    
    /**
     * è·å–è¿é€šåˆ†é‡æ•°é‡
     * @return è¿é€šåˆ†é‡æ•°é‡
     */
    public int getCount() {
        return count;
    }
}
```

---

## å¸¸è§ç®—æ³•

### 1. æœ€çŸ­è·¯å¾„ç®—æ³•

#### BFSï¼ˆæ— æƒå›¾æœ€çŸ­è·¯å¾„ï¼‰

```java
/**
 * BFSæ±‚æœ€çŸ­è·¯å¾„
 * @param start èµ·ç‚¹
 * @param end ç»ˆç‚¹
 * @param adj é‚»æ¥è¡¨
 * @return æœ€çŸ­è·ç¦»
 */
int shortestPath(int start, int end, List<List<Integer>> adj) {
    Queue<Integer> queue = new LinkedList<>();
    int[] dist = new int[adj.size()];
    Arrays.fill(dist, -1);
    
    queue.offer(start);
    dist[start] = 0;
    
    while (!queue.isEmpty()) {
        int u = queue.poll();
        
        if (u == end) return dist[end];
        
        for (int v : adj.get(u)) {
            if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                queue.offer(v);
            }
        }
    }
    
    return -1;  // ä¸å¯è¾¾
}
```

#### Dijkstraç®—æ³•ï¼ˆå¸¦æƒå›¾æœ€çŸ­è·¯å¾„ï¼‰

```java
/**
 * Dijkstraç®—æ³•ï¼ˆä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼‰
 * @param start èµ·ç‚¹
 * @param n èŠ‚ç‚¹æ•°é‡
 * @param graph é‚»æ¥è¡¨ï¼Œgraph[u] = [(v1, w1), (v2, w2), ...]
 * @return ä»startåˆ°å„ç‚¹çš„æœ€çŸ­è·ç¦»
 */
int[] dijkstra(int start, int n, List<List<int[]>> graph) {
    int[] dist = new int[n];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[start] = 0;
    
    // ä¼˜å…ˆé˜Ÿåˆ—ï¼š[è·ç¦», èŠ‚ç‚¹]
    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
    pq.offer(new int[]{0, start});
    
    while (!pq.isEmpty()) {
        int[] curr = pq.poll();
        int d = curr[0];
        int u = curr[1];
        
        if (d > dist[u]) continue;  // å·²ç»æ‰¾åˆ°æ›´çŸ­è·¯å¾„
        
        for (int[] edge : graph.get(u)) {
            int v = edge[0];
            int w = edge[1];
            
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.offer(new int[]{dist[v], v});
            }
        }
    }
    
    return dist;
}
```

### 2. æ‹“æ‰‘æ’åº

**åº”ç”¨åœºæ™¯**ï¼šè¯¾ç¨‹ä¾èµ–ã€ä»»åŠ¡è°ƒåº¦

```java
/**
 * æ‹“æ‰‘æ’åºï¼ˆKahnç®—æ³• - BFSï¼‰
 * @param n èŠ‚ç‚¹æ•°é‡
 * @param edges è¾¹åˆ—è¡¨ï¼Œ[u, v] è¡¨ç¤º u -> v
 * @return æ‹“æ‰‘æ’åºç»“æœï¼Œå¦‚æœæœ‰ç¯è¿”å›ç©ºåˆ—è¡¨
 */
List<Integer> topologicalSort(int n, int[][] edges) {
    // æ„å»ºé‚»æ¥è¡¨å’Œå…¥åº¦æ•°ç»„
    List<List<Integer>> adj = new ArrayList<>();
    int[] inDegree = new int[n];
    
    for (int i = 0; i < n; i++) {
        adj.add(new ArrayList<>());
    }
    
    for (int[] edge : edges) {
        adj.get(edge[0]).add(edge[1]);
        inDegree[edge[1]]++;
    }
    
    // BFS
    Queue<Integer> queue = new LinkedList<>();
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            queue.offer(i);
        }
    }
    
    List<Integer> result = new ArrayList<>();
    while (!queue.isEmpty()) {
        int u = queue.poll();
        result.add(u);
        
        for (int v : adj.get(u)) {
            inDegree[v]--;
            if (inDegree[v] == 0) {
                queue.offer(v);
            }
        }
    }
    
    // å¦‚æœæ‰€æœ‰èŠ‚ç‚¹éƒ½è¢«è®¿é—®ï¼Œè¯´æ˜æ— ç¯
    return result.size() == n ? result : new ArrayList<>();
}
```

### 3. æœ€å°ç”Ÿæˆæ ‘

#### Kruskalç®—æ³•ï¼ˆä½¿ç”¨å¹¶æŸ¥é›†ï¼‰

```java
/**
 * Kruskalç®—æ³•æ±‚æœ€å°ç”Ÿæˆæ ‘
 * @param n èŠ‚ç‚¹æ•°é‡
 * @param edges è¾¹åˆ—è¡¨ï¼Œ[u, v, weight]
 * @return æœ€å°ç”Ÿæˆæ ‘çš„æ€»æƒé‡
 */
int kruskal(int n, int[][] edges) {
    // æŒ‰æƒé‡æ’åº
    Arrays.sort(edges, (a, b) -> a[2] - b[2]);
    
    UnionFind uf = new UnionFind(n);
    int totalWeight = 0;
    int edgeCount = 0;
    
    for (int[] edge : edges) {
        int u = edge[0];
        int v = edge[1];
        int w = edge[2];
        
        // å¦‚æœuå’Œvä¸åœ¨åŒä¸€é›†åˆï¼Œæ·»åŠ è¿™æ¡è¾¹
        if (!uf.isConnected(u, v)) {
            uf.union(u, v);
            totalWeight += w;
            edgeCount++;
            
            // æœ€å°ç”Ÿæˆæ ‘æœ‰n-1æ¡è¾¹
            if (edgeCount == n - 1) break;
        }
    }
    
    return edgeCount == n - 1 ? totalWeight : -1;
}
```

---

## å®æˆ˜åº”ç”¨

### 1. å²›å±¿æ•°é‡ï¼ˆLeetCode 200ï¼‰

**é—®é¢˜**ï¼šç»™å®šä¸€ä¸ªäºŒç»´ç½‘æ ¼ï¼Œ'1'è¡¨ç¤ºé™†åœ°ï¼Œ'0'è¡¨ç¤ºæ°´ï¼Œè®¡ç®—å²›å±¿æ•°é‡ã€‚

```java
/**
 * æ–¹æ³•1ï¼šDFS
 */
public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0) return 0;
    
    int count = 0;
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (grid[i][j] == '1') {
                count++;
                dfs(grid, i, j);
            }
        }
    }
    return count;
}

private void dfs(char[][] grid, int i, int j) {
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0') {
        return;
    }
    
    grid[i][j] = '0';  // æ ‡è®°ä¸ºå·²è®¿é—®
    
    // ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘
    dfs(grid, i - 1, j);
    dfs(grid, i + 1, j);
    dfs(grid, i, j - 1);
    dfs(grid, i, j + 1);
}
```

### 2. çœä»½æ•°é‡ï¼ˆLeetCode 547ï¼‰

**é—®é¢˜**ï¼šç»™å®šä¸€ä¸ªé‚»æ¥çŸ©é˜µï¼Œè®¡ç®—æœ‰å¤šå°‘ä¸ªçœä»½ï¼ˆè¿é€šåˆ†é‡ï¼‰ã€‚

```java
/**
 * æ–¹æ³•1ï¼šå¹¶æŸ¥é›†
 */
public int findCircleNum(int[][] isConnected) {
    int n = isConnected.length;
    UnionFind uf = new UnionFind(n);
    
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (isConnected[i][j] == 1) {
                uf.union(i, j);
            }
        }
    }
    
    return uf.getCount();
}
```

### 3. è¯¾ç¨‹è¡¨ï¼ˆLeetCode 207ï¼‰

**é—®é¢˜**ï¼šåˆ¤æ–­èƒ½å¦å®Œæˆæ‰€æœ‰è¯¾ç¨‹ï¼ˆæ£€æµ‹æœ‰å‘å›¾æ˜¯å¦æœ‰ç¯ï¼‰ã€‚

```java
/**
 * æ‹“æ‰‘æ’åºåˆ¤æ–­æ˜¯å¦æœ‰ç¯
 */
public boolean canFinish(int numCourses, int[][] prerequisites) {
    List<List<Integer>> adj = new ArrayList<>();
    int[] inDegree = new int[numCourses];
    
    for (int i = 0; i < numCourses; i++) {
        adj.add(new ArrayList<>());
    }
    
    for (int[] pre : prerequisites) {
        adj.get(pre[1]).add(pre[0]);
        inDegree[pre[0]]++;
    }
    
    Queue<Integer> queue = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
        if (inDegree[i] == 0) {
            queue.offer(i);
        }
    }
    
    int count = 0;
    while (!queue.isEmpty()) {
        int u = queue.poll();
        count++;
        
        for (int v : adj.get(u)) {
            inDegree[v]--;
            if (inDegree[v] == 0) {
                queue.offer(v);
            }
        }
    }
    
    return count == numCourses;
}
```

---

## æ€»ç»“

### æ•°æ®ç»“æ„é€‰æ‹©æŒ‡å—

| åœºæ™¯ | æ¨èæ•°æ®ç»“æ„ | åŸå›  |
|------|------------|------|
| **å±‚æ¬¡å…³ç³»** | æ ‘ | æ˜ç¡®çš„çˆ¶å­å…³ç³» |
| **ç½‘ç»œå…³ç³»** | å›¾ | å¤æ‚çš„å¤šå¯¹å¤šå…³ç³» |
| **è¿é€šæ€§æŸ¥è¯¢** | å¹¶æŸ¥é›† | å¿«é€Ÿåˆ¤æ–­æ˜¯å¦è¿é€š |
| **æœ€çŸ­è·¯å¾„** | å›¾ + BFS/Dijkstra | æ‰¾æœ€çŸ­è·¯å¾„ |
| **ä¾èµ–å…³ç³»** | æœ‰å‘å›¾ + æ‹“æ‰‘æ’åº | å¤„ç†ä¾èµ– |

### ç®—æ³•å¤æ‚åº¦å¯¹æ¯”

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|-----------|-----------|---------|
| **DFS** | O(V + E) | O(V) | è·¯å¾„é—®é¢˜ã€è¿é€šæ€§ |
| **BFS** | O(V + E) | O(V) | æœ€çŸ­è·¯å¾„ã€å±‚æ¬¡éå† |
| **å¹¶æŸ¥é›†** | O(Î±(n)) | O(n) | åŠ¨æ€è¿é€šæ€§ |
| **Dijkstra** | O((V+E)logV) | O(V) | å¸¦æƒæœ€çŸ­è·¯å¾„ |
| **æ‹“æ‰‘æ’åº** | O(V + E) | O(V) | ä¾èµ–å…³ç³»æ’åº |

### å­¦ä¹ è·¯çº¿å»ºè®®

```mermaid
graph LR
    A[1. æ ‘çš„åŸºç¡€] --> B[2. äºŒå‰æ ‘éå†]
    B --> C[3. å›¾çš„è¡¨ç¤º]
    C --> D[4. DFS/BFS]
    D --> E[5. å¹¶æŸ¥é›†]
    E --> F[6. æœ€çŸ­è·¯å¾„]
    F --> G[7. æ‹“æ‰‘æ’åº]
    
    style A fill:#ff6b6b
    style B fill:#ff6b6b
    style C fill:#339af0
    style D fill:#339af0
    style E fill:#51cf66
    style F fill:#ffd43b
    style G fill:#ffd43b
```

**æ¨èç»ƒä¹ é¢˜ç›®**ï¼š

1. **æ ‘çš„åŸºç¡€**
   - LeetCode 104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦
   - LeetCode 226. ç¿»è½¬äºŒå‰æ ‘

2. **å›¾çš„éå†**
   - LeetCode 200. å²›å±¿æ•°é‡
   - LeetCode 133. å…‹éš†å›¾

3. **å¹¶æŸ¥é›†**
   - LeetCode 547. çœä»½æ•°é‡ â­ï¼ˆå…¥é—¨ï¼‰
   - LeetCode 684. å†—ä½™è¿æ¥
   - LeetCode 3607. ç”µç½‘ç»´æŠ¤ â­â­ï¼ˆè¿›é˜¶ï¼‰

4. **æœ€çŸ­è·¯å¾„**
   - LeetCode 1091. äºŒè¿›åˆ¶çŸ©é˜µä¸­çš„æœ€çŸ­è·¯å¾„
   - LeetCode 743. ç½‘ç»œå»¶è¿Ÿæ—¶é—´

5. **æ‹“æ‰‘æ’åº**
   - LeetCode 207. è¯¾ç¨‹è¡¨
   - LeetCode 210. è¯¾ç¨‹è¡¨ II

---

## é™„å½•ï¼šå¸¸ç”¨ä»£ç æ¨¡æ¿

### äºŒå‰æ ‘èŠ‚ç‚¹

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int val) { this.val = val; }
}
```

### å›¾çš„é‚»æ¥è¡¨

```java
List<List<Integer>> adj = new ArrayList<>();
for (int i = 0; i < n; i++) {
    adj.add(new ArrayList<>());
}
```

### DFSæ¨¡æ¿

```java
void dfs(int u, boolean[] visited, List<List<Integer>> adj) {
    visited[u] = true;
    for (int v : adj.get(u)) {
        if (!visited[v]) {
            dfs(v, visited, adj);
        }
    }
}
```

### BFSæ¨¡æ¿

```java
void bfs(int start, List<List<Integer>> adj) {
    boolean[] visited = new boolean[adj.size()];
    Queue<Integer> queue = new LinkedList<>();
    
    queue.offer(start);
    visited[start] = true;
    
    while (!queue.isEmpty()) {
        int u = queue.poll();
        for (int v : adj.get(u)) {
            if (!visited[v]) {
                visited[v] = true;
                queue.offer(v);
            }
        }
    }
}
```

### å¹¶æŸ¥é›†æ¨¡æ¿

```java
class UnionFind {
    int[] parent, rank;
    
    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 1;
        }
    }
    
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) return;
        
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
    }
}
```

---

**ç¥æ‚¨å­¦ä¹ æ„‰å¿«ï¼ğŸ‰**

æœ‰ä»»ä½•é—®é¢˜ï¼Œéšæ—¶å›æ¥æŸ¥é˜…è¿™ä»½æ–‡æ¡£ï¼





