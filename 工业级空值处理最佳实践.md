# 工业级空值处理最佳实践指南

## 目录
1. [概述](#概述)
2. [传统Java空值检查](#传统java空值检查)
3. [Java 8+ 现代空值处理](#java-8-现代空值处理)
4. [第三方库解决方案](#第三方库解决方案)
5. [设计模式应用](#设计模式应用)
6. [现代Java特性](#现代java特性)
7. [实际项目应用](#实际项目应用)
8. [最佳实践总结](#最佳实践总结)
9. [反模式避免](#反模式避免)

## 概述

空值处理是工业级Java开发中的关键质量保证点。良好的空值处理策略能够：
- 提高代码健壮性
- 减少运行时异常
- 增强代码可读性
- 降低维护成本

## 传统Java空值检查

### 基础空值检查
```java
// 基本对象检查
if (object != null) {
    // 安全使用object
}

// 字符串空值检查
if (str != null && !str.isEmpty()) {
    // 使用非空字符串
}

// 集合空值检查
if (list != null && !list.isEmpty()) {
    // 使用非空集合
}

// 数组空值检查
if (array != null && array.length > 0) {
    // 使用非空数组
}
```

### 防御性编程
```java
public String processString(String input) {
    // 方法入口检查
    if (input == null) {
        return ""; // 提供默认值
    }
    return input.trim();//去除空白字符，包括空格 (' ')、制表符 ('\t')、换行符 ('\n')、回车符 ('\r')
}

public List<String> processList(List<String> list) {
    // 返回空集合而不是null
    if (list == null) {
        return Collections.emptyList();
    }
    return list.stream()
        .filter(Objects::nonNull)
        .collect(Collectors.toList());
}
```

## Java 8+ 现代空值处理

### Optional类（强烈推荐）

#### 基本使用
```java
import java.util.Optional;

// 创建Optional：创建一个 Optional 对象，包装一个可能为 null 的值
// 如果值是 null：返回一个空的 Optional。
// 如果值非 null：返回一个包含该值的 Optional。
Optional<String> optional = Optional.ofNullable(getString());

// 安全使用
// ifPresent作用：如果 Optional 中有值，就执行你提供的操作（比如打印）。
optional.ifPresent(value -> System.out.println(value));

// 提供默认值
// orElse作用：如果 Optional 有值就返回该值，否则返回你提供的默认值。
String result = optional.orElse("默认值");

// 链式调用
// filter作用：对 Optional 中的值进行条件过滤。如果条件不满足：返回空的 Optional。如果满足：保留原值。
String result = optional
    .map(String::toUpperCase)
    .filter(s -> s.length() > 3)
    .orElse("默认值");

// 抛出异常
String result = optional.orElseThrow(() -> 
    new IllegalArgumentException("值不能为空"));
```

#### 高级用法
```java
// 嵌套Optional处理
Optional<User> user = getUserById(id);//getUserById(id) 返回一个 Optional<User>，可能为空。
String email = user
    .map(User::getProfile)//如果有值，提取 User 的 Profile
    .map(Profile::getEmail)//再从 Profile 中提取 email
    .orElse("unknown@example.com");//如果整个链条中任何一步是空，就返回默认值

// 条件执行
// Optional 的新方法 ifPresentOrElse（Java 9+），比传统的 ifPresent 更强大，因为它同时处理了有值和无值的情况。
user.ifPresentOrElse(
    u -> System.out.println("用户存在: " + u.getName()),
    () -> System.out.println("用户不存在")
);

// 转换和过滤:从 users 列表中提取所有合法的 email 地址（非空且包含 @）
List<String> validEmails = users.stream()//将集合转换成“流”，以便进行链式处理
    .map(User::getEmail)//返回 Optional<String>
    .filter(Optional::isPresent)//过滤掉空的 Optional
    .map(Optional::get)//提取出真正的 email 字符串
    .filter(email -> email.contains("@"))//过滤掉不合法的 email
    .collect(Collectors.toList());//收集成 List
```

### Objects工具类
```java
import java.util.Objects;

// 空值检查
if (Objects.nonNull(obj)) {
    // 使用obj
}

// 空值安全比较
boolean equal = Objects.equals(obj1, obj2);
// 源码如下：
public static boolean equals(Object a, Object b) {
    return (a == b) || (a != null && a.equals(b));
}
// 空值安全哈希
int hash = Objects.hash(obj1, obj2, obj3);

// 空值安全toString
String str = Objects.toString(obj, "默认值");
```

## 第三方库解决方案

### Apache Commons Lang
```java
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.ObjectUtils;

// 字符串空值检查
if (StringUtils.isNotBlank(str)) {
    // 使用非空字符串
}

// 对象空值检查
if (ObjectUtils.isNotEmpty(obj)) {
    // 使用非空对象
}

// 空值安全方法
String result = StringUtils.defaultIfBlank(input, "默认值");
```

### Google Guava
```java
import com.google.common.base.Strings;
import com.google.common.base.Preconditions;
import com.google.common.base.Optional;

// 字符串空值处理
String result = Strings.nullToEmpty(input);

// 前置条件检查
Preconditions.checkNotNull(obj, "对象不能为空");
Preconditions.checkArgument(!Strings.isNullOrEmpty(str), "字符串不能为空");

// Guava的Optional（Java 8之前使用）
Optional<String> optional = Optional.fromNullable(getString());
```

### Spring Framework
```java
import org.springframework.util.StringUtils;
import org.springframework.util.CollectionUtils;

// Spring的空值检查
if (StringUtils.hasText(str)) {
    // 使用非空字符串
}

if (!CollectionUtils.isEmpty(list)) {
    // 使用非空集合
}
```

## 设计模式应用

### 空对象模式（Null Object Pattern）
```java
// 定义空对象接口
public interface ListNode {
    int getVal();
    ListNode getNext();
    boolean isEmpty();
    String toString();
}

// 空对象实现
public class EmptyListNode implements ListNode {
    @Override
    public int getVal() {
        return 0;
    }
    
    @Override
    public ListNode getNext() {
        return this; // 返回自己
    }
    
    @Override
    public boolean isEmpty() {
        return true;
    }
    
    @Override
    public String toString() {
        return "[]";
    }
}

// 正常实现
public class ConcreteListNode implements ListNode {
    private final int val;
    private final ListNode next;
    
    public ConcreteListNode(int val, ListNode next) {
        this.val = val;
        this.next = next != null ? next : new EmptyListNode();
    }
    
    @Override
    public boolean isEmpty() {
        return false;
    }
    
    // ... 其他方法实现
}
```

### 建造者模式 + 空值检查
```java
public class ListNodeBuilder {
    private int val;
    private ListNode next;
    
    public ListNodeBuilder val(int val) {
        this.val = val;
        return this;
    }
    
    public ListNodeBuilder next(ListNode next) {
        this.next = next;
        return this;
    }
    
    public ListNode build() {
        // 构建时进行空值检查
        if (next == null) {
            return new ConcreteListNode(val, new EmptyListNode());
        }
        return new ConcreteListNode(val, next);
    }
}
```

## 现代Java特性

### 记录类（Record）的空值处理
```java
public record ListNodeRecord(int val, ListNodeRecord next) {
    public ListNodeRecord {
        // 紧凑构造函数中的验证
        if (val < 0) {
            throw new IllegalArgumentException("值不能为负数");
        }
    }
    
    public Optional<ListNodeRecord> getNext() {
        return Optional.ofNullable(next);
    }
    
    public boolean hasNext() {
        return next != null;
    }
}
```

### 模式匹配（Java 17+）
```java
public String processNode(Object obj) {
    return switch (obj) {
        case null -> "空值";
        case ListNode node -> "链表节点: " + node.getVal();
        case String str when !str.isEmpty() -> "非空字符串: " + str;
        case String str -> "空字符串";
        default -> "未知类型";
    };
}
```

### 文本块（Java 15+）
```java
public String generateReport(Object data) {
    return Optional.ofNullable(data)
        .map(d -> """
            数据报告:
            类型: %s
            值: %s
            时间: %s
            """.formatted(
                d.getClass().getSimpleName(),
                d.toString(),
                LocalDateTime.now()
            ))
        .orElse("无数据可报告");
}
```

## 实际项目应用

### 改进的ListNode类
```java
public static class ListNode {
    private final int val;
    private final ListNode next;
    
    // 私有构造函数，强制使用工厂方法
    private ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
    
    // 工厂方法，内置空值检查
    public static ListNode of(int val) {
        return new ListNode(val, null);
    }
    
    public static ListNode of(int val, ListNode next) {
        return new ListNode(val, next);
    }
    
    // 安全的访问方法
    public Optional<ListNode> getNext() {
        return Optional.ofNullable(next);
    }
    
    public boolean hasNext() {
        return next != null;
    }
    
    // 安全的toString
    @Override
    public String toString() {
        return toStringWithLimit(20); // 限制长度防止无限循环
    }
    
    private String toStringWithLimit(int limit) {
        StringBuilder sb = new StringBuilder();
        ListNode current = this;
        int count = 0;
        
        while (current != null && count < limit) {
            sb.append(current.val);
            if (current.hasNext()) {
                sb.append(" -> ");
            }
            current = current.next;
            count++;
        }
        
        if (current != null) {
            sb.append("...");
        }
        
        return sb.toString();
    }
}
```

### 服务层空值处理
```java
@Service
public class UserService {
    
    public Optional<User> findUserById(Long id) {
        return Optional.ofNullable(id)
            .filter(i -> i > 0)
            .map(userRepository::findById)
            .orElse(Optional.empty());
    }
    
    public User createUser(UserRequest request) {
        return Optional.ofNullable(request)
            .filter(req -> StringUtils.hasText(req.getName()))
            .map(req -> User.builder()
                .name(req.getName())
                .email(req.getEmail())
                .build())
            .orElseThrow(() -> new IllegalArgumentException("无效的用户请求"));
    }
}
```

### 控制器层空值处理
```java
@RestController
public class UserController {
    
    @GetMapping("/users/{id}")
    public ResponseEntity<UserResponse> getUser(@PathVariable Long id) {
        return userService.findUserById(id)
            .map(user -> ResponseEntity.ok(UserResponse.from(user)))
            .orElse(ResponseEntity.notFound().build());
    }
    
    @PostMapping("/users")
    public ResponseEntity<UserResponse> createUser(@RequestBody UserRequest request) {
        try {
            User user = userService.createUser(request);
            return ResponseEntity.ok(UserResponse.from(user));
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().build();
        }
    }
}
```

## 最佳实践总结

### 推荐策略（按优先级）

1. **Optional类** - 现代Java标准
   - 用于方法返回值
   - 链式调用处理
   - 避免返回null

2. **防御性编程** - 在方法入口检查
   - 参数验证
   - 提供默认值
   - 早期返回

3. **空对象模式** - 避免返回null
   - 定义空对象实现
   - 统一接口处理
   - 减少null检查

4. **第三方库** - Apache Commons、Guava
   - 工具类方法
   - 前置条件检查
   - 空值安全操作

5. **前置条件检查** - 使用断言或Preconditions
   - 方法入口验证
   - 快速失败原则
   - 清晰的错误信息

### 性能考虑

```java
// 性能优化的空值检查
public boolean isNotEmpty(String str) {
    return str != null && !str.isEmpty();
}

// 使用Objects.requireNonNull进行快速失败
public void processObject(Object obj) {
    Objects.requireNonNull(obj, "对象不能为空");
    // 处理逻辑
}

// 批量空值检查
public boolean allNotNull(Object... objects) {
    return Arrays.stream(objects).noneMatch(Objects::isNull);
}
```

## 反模式避免

### ❌ 不好的做法
```java
// 深层嵌套检查
if (obj != null && obj.method() != null && obj.method().getValue() != null) {
    // 使用obj.method().getValue()
}

// 返回null
public String getValue() {
    if (condition) {
        return "value";
    }
    return null; // 避免这样做
}

// 忽略空值
public void process(String str) {
    str.toUpperCase(); // 可能抛出NPE
}
```

### ✅ 好的做法
```java
// 使用Optional链式调用
Optional.ofNullable(obj)
    .map(Object::method)
    .map(Method::getValue)
    .ifPresent(value -> {
        // 使用value
    });

// 返回Optional或空对象
public Optional<String> getValue() {
    if (condition) {
        return Optional.of("value");
    }
    return Optional.empty();
}

// 防御性编程
public void process(String str) {
    Optional.ofNullable(str)
        .map(String::toUpperCase)
        .ifPresent(System.out::println);
}
```

## 工具和IDE支持

### IDE插件推荐
- **SpotBugs** - 静态代码分析
- **SonarQube** - 代码质量检查
- **IntelliJ IDEA** - 内置空值检查
- **Eclipse** - 空值分析工具

### 代码检查规则
```java
// 使用@NonNull和@Nullable注解
public void process(@NonNull String input, @Nullable String optional) {
    // IDE会提供空值检查提示
}

// 使用@SuppressWarnings抑制警告
@SuppressWarnings("null")
public void legacyMethod() {
    // 遗留代码处理
}
```

## 总结

工业级空值处理的核心原则：
1. **预防胜于治疗** - 在源头避免null
2. **明确意图** - 使用Optional表达可能为空
3. **快速失败** - 尽早发现和处理空值
4. **一致性** - 在整个项目中保持统一的空值处理策略
5. **可读性** - 代码应该清楚地表达空值处理逻辑

通过遵循这些最佳实践，可以显著提高Java代码的健壮性和可维护性。

# 📊 Java Stream 流程图模拟：提取合法 Email

## 输入集合：List<User> users

每个 User 对象结构如下：
- name: String
- email: Optional<String>

---

## 🔄 流程图步骤

1️⃣ users.stream()  
  ⬇️ 将 List<User> 转换为 Stream<User>（懒加载）

2️⃣ map(User::getEmail)  
  ⬇️ 对每个 User 调用 getEmail()  
  ➡️ 得到 Stream<Optional<String>>

3️⃣ filter(Optional::isPresent)  
  ⬇️ 过滤掉 Optional.empty()  
  ➡️ 得到 Stream<Optional<String>>（只保留非空）

4️⃣ map(Optional::get)  
  ⬇️ 提取 Optional 中的值  
  ➡️ 得到 Stream<String>

5️⃣ filter(email -> email.contains("@"))  
  ⬇️ 过滤掉不包含 @ 的 email  
  ➡️ 得到合法 email 的 Stream<String>

6️⃣ collect(Collectors.toList())  
  ⬇️ 收集结果为 List<String>  
  ✅ 输出合法 email 列表

---

## 🧠 可视化类比（数据流动）

```text
[User1] ──▶ getEmail() ──▶ Optional.of("a@b.com") ──▶ 保留 ──▶ "a@b.com" ──▶ 合法 ──▶ ✅  
[User2] ──▶ getEmail() ──▶ Optional.empty()       ──▶ 丢弃 ──▶ ✘  
[User3] ──▶ getEmail() ──▶ Optional.of("abc")     ──▶ 保留 ──▶ "abc"     ──▶ 非法 ──▶ ✘  
[User4] ──▶ getEmail() ──▶ Optional.of("x@y.com") ──▶ 保留 ──▶ "x@y.com" ──▶ 合法 ──▶ ✅  
