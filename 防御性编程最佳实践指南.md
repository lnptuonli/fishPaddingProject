# 防御性编程最佳实践指南

## 目录
1. [概述](#概述)
2. [核心原则](#核心原则)
3. [输入验证防御](#输入验证防御)
4. [空值防御](#空值防御)
5. [资源管理防御](#资源管理防御)
6. [状态检查防御](#状态检查防御)
7. [异常处理防御](#异常处理防御)
8. [并发安全防御](#并发安全防御)
9. [性能防御](#性能防御)
10. [安全防御](#安全防御)
11. [实际项目应用](#实际项目应用)
12. [最佳实践总结](#最佳实践总结)
13. [反模式避免](#反模式避免)

## 概述

防御性编程（Defensive Programming）是一种编程哲学和技巧，其核心思想是**假设代码会在不理想的环境中运行，并为此做好准备**。

### 为什么需要防御性编程？

- **提高健壮性** - 代码能够处理意外情况
- **减少系统崩溃** - 降低运行时异常的发生
- **便于调试** - 提供清晰的错误信息
- **增强可维护性** - 代码意图明确，减少隐藏bug
- **提高用户体验** - 系统更加稳定可靠

## 核心原则

### 1. 假设最坏情况
```java
// 假设输入可能无效、系统可能出错
public void processData(String input) {
    // 不假设input是有效的
    if (input == null || input.trim().isEmpty()) {
        throw new IllegalArgumentException("输入不能为空");
    }
    // 处理逻辑...
}
```

### 2. 快速失败
```java
// 在问题出现时立即检测并处理
public void validateUser(User user) {
    if (user == null) {
        throw new IllegalArgumentException("用户不能为空");
    }
    if (user.getName() == null) {
        throw new IllegalArgumentException("用户名不能为空");
    }
    // 继续验证...
}
```

### 3. 优雅降级
```java
// 即使部分功能失败，系统仍能继续运行
public String getCachedData(String key) {
    try {
        return cache.get(key);
    } catch (Exception e) {
        logger.warn("缓存获取失败，使用默认值", e);
        return getDefaultValue();
    }
}
```

### 4. 明确错误信息
```java
// 提供清晰的错误反馈
public void transferMoney(Account from, Account to, BigDecimal amount) {
    if (from == null) {
        throw new IllegalArgumentException("转出账户不能为空");
    }
    if (to == null) {
        throw new IllegalArgumentException("转入账户不能为空");
    }
    if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
        throw new IllegalArgumentException("转账金额必须大于0");
    }
    // 业务逻辑...
}
```

## 输入验证防御

### 基础输入验证
```java
public class UserService {
    
    // ❌ 不防御的写法
    public void createUser(String name, int age) {
        User user = new User(name, age);
        userRepository.save(user);
    }
    
    // ✅ 防御性编程
    public void createUser(String name, int age) {
        // 参数验证
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("用户名不能为空");
        }
        
        if (age < 0 || age > 150) {
            throw new IllegalArgumentException("年龄必须在0-150之间");
        }
        
        // 业务逻辑验证
        if (userRepository.existsByName(name.trim())) {
            throw new BusinessException("用户名已存在");
        }
        
        User user = new User(name.trim(), age);
        userRepository.save(user);
    }
}
```

### 复杂对象验证
```java
public class OrderValidator {
    
    public void validateOrder(Order order) {
        // 对象空值检查
        Objects.requireNonNull(order, "订单不能为空");
        
        // 嵌套对象验证
        if (order.getCustomer() == null) {
            throw new ValidationException("订单必须关联客户");
        }
        
        if (order.getItems() == null || order.getItems().isEmpty()) {
            throw new ValidationException("订单必须包含商品");
        }
        
        // 集合元素验证
        for (OrderItem item : order.getItems()) {
            validateOrderItem(item);
        }
        
        // 业务规则验证
        if (order.getTotalAmount().compareTo(BigDecimal.ZERO) <= 0) {
            throw new ValidationException("订单金额必须大于0");
        }
    }
    
    private void validateOrderItem(OrderItem item) {
        if (item.getProduct() == null) {
            throw new ValidationException("订单项必须关联商品");
        }
        
        if (item.getQuantity() <= 0) {
            throw new ValidationException("商品数量必须大于0");
        }
    }
}
```

### 使用验证框架
```java
// 使用Bean Validation
public class User {
    @NotNull(message = "用户名不能为空")
    @Size(min = 2, max = 50, message = "用户名长度必须在2-50之间")
    private String name;
    
    @NotNull(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;
    
    @Min(value = 0, message = "年龄不能为负数")
    @Max(value = 150, message = "年龄不能超过150")
    private Integer age;
}

// 在服务层使用验证
@Service
public class UserService {
    
    public void createUser(@Valid User user) {
        // 验证会自动进行
        userRepository.save(user);
    }
}
```

## 空值防御

### 基础空值检查
```java
public class DataProcessor {
    
    // ❌ 不防御的写法
    public String processData(List<String> data) {
        StringBuilder result = new StringBuilder();
        for (String item : data) {
            result.append(item.toUpperCase());
        }
        return result.toString();
    }
    
    // ✅ 防御性编程
    public String processData(List<String> data) {
        // 空值检查
        if (data == null) {
            return "";
        }
        
        StringBuilder result = new StringBuilder();
        for (String item : data) {
            // 防御空元素
            if (item != null) {
                result.append(item.toUpperCase());
            }
        }
        return result.toString();
    }
}
```

### 使用Optional防御
```java
public class UserService {
    
    public Optional<User> findUserById(Long id) {
        // 防御空ID
        if (id == null || id <= 0) {
            return Optional.empty();
        }
        
        return Optional.ofNullable(userRepository.findById(id));
    }
    
    public String getUserDisplayName(Long id) {
        return findUserById(id)
            .map(User::getName)
            .filter(name -> !name.trim().isEmpty())
            .orElse("未知用户");
    }
}
```

### 集合操作防御
```java
public class CollectionUtils {
    
    public static <T> List<T> safeFilter(List<T> list, Predicate<T> predicate) {
        if (list == null) {
            return Collections.emptyList();
        }
        
        return list.stream()
            .filter(Objects::nonNull)
            .filter(predicate)
            .collect(Collectors.toList());
    }
    
    public static <T> T safeGet(List<T> list, int index) {
        if (list == null || index < 0 || index >= list.size()) {
            return null;
        }
        return list.get(index);
    }
}
```

## 资源管理防御

### 文件操作防御
```java
public class FileProcessor {
    
    // ✅ 防御性编程 - 资源管理
    public String readFile(String filePath) {
        // 参数验证
        if (filePath == null || filePath.trim().isEmpty()) {
            throw new IllegalArgumentException("文件路径不能为空");
        }
        
        File file = new File(filePath);
        
        // 文件存在性检查
        if (!file.exists()) {
            throw new FileNotFoundException("文件不存在: " + filePath);
        }
        
        // 文件权限检查
        if (!file.canRead()) {
            throw new SecurityException("文件不可读: " + filePath);
        }
        
        // 文件大小检查
        if (file.length() > MAX_FILE_SIZE) {
            throw new IllegalArgumentException("文件过大: " + file.length());
        }
        
        // 使用try-with-resources确保资源释放
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            StringBuilder content = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append("\n");
            }
            return content.toString();
        } catch (IOException e) {
            throw new RuntimeException("读取文件失败: " + filePath, e);
        }
    }
}
```

### 数据库连接防御
```java
public class DatabaseManager {
    private static final int MAX_RETRY_ATTEMPTS = 3;
    private static final long RETRY_DELAY_MS = 1000;
    
    public Connection getConnection(String url, String username, String password) {
        // 参数验证
        if (url == null || url.trim().isEmpty()) {
            throw new IllegalArgumentException("数据库URL不能为空");
        }
        
        // 重试机制
        Exception lastException = null;
        for (int attempt = 1; attempt <= MAX_RETRY_ATTEMPTS; attempt++) {
            try {
                Connection connection = DriverManager.getConnection(url, username, password);
                
                // 连接有效性检查
                if (connection.isValid(5)) {
                    return connection;
                } else {
                    connection.close();
                    throw new SQLException("连接无效");
                }
                
            } catch (SQLException e) {
                lastException = e;
                logger.warn("数据库连接失败，尝试第{}次", attempt, e);
                
                if (attempt < MAX_RETRY_ATTEMPTS) {
                    try {
                        Thread.sleep(RETRY_DELAY_MS);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        throw new RuntimeException("连接被中断", ie);
                    }
                }
            }
        }
        
        throw new RuntimeException("数据库连接失败，已重试" + MAX_RETRY_ATTEMPTS + "次", lastException);
    }
}
```

## 状态检查防御

### 对象状态防御
```java
public class ConnectionManager {
    private volatile boolean connected = false;
    private volatile Connection connection;
    private final Object lock = new Object();
    
    public void connect(String url) {
        synchronized (lock) {
            // 状态检查
            if (connected) {
                throw new IllegalStateException("已经连接，请先断开连接");
            }
            
            if (url == null || url.trim().isEmpty()) {
                throw new IllegalArgumentException("连接URL不能为空");
            }
            
            try {
                connection = DriverManager.getConnection(url);
                
                // 连接有效性验证
                if (!connection.isValid(5)) {
                    connection.close();
                    throw new SQLException("连接无效");
                }
                
                connected = true;
                logger.info("数据库连接成功: {}", url);
                
            } catch (SQLException e) {
                connected = false;
                connection = null;
                throw new RuntimeException("连接失败: " + url, e);
            }
        }
    }
    
    public void disconnect() {
        synchronized (lock) {
            if (!connected) {
                return; // 已经断开，无需操作
            }
            
            try {
                if (connection != null && !connection.isClosed()) {
                    connection.close();
                }
            } catch (SQLException e) {
                // 记录日志，但不抛出异常
                logger.warn("断开连接时发生异常", e);
            } finally {
                connected = false;
                connection = null;
                logger.info("数据库连接已断开");
            }
        }
    }
    
    public boolean isConnected() {
        synchronized (lock) {
            return connected && connection != null && !connection.isClosed();
        }
    }
}
```

### 业务状态防御
```java
public class OrderService {
    
    public void processOrder(Order order) {
        // 订单状态检查
        if (order.getStatus() != OrderStatus.PENDING) {
            throw new IllegalStateException("只能处理待处理状态的订单");
        }
        
        // 库存检查
        for (OrderItem item : order.getItems()) {
            if (!inventoryService.hasStock(item.getProduct(), item.getQuantity())) {
                throw new BusinessException("商品库存不足: " + item.getProduct().getName());
            }
        }
        
        // 支付状态检查
        if (order.getPaymentStatus() != PaymentStatus.PAID) {
            throw new BusinessException("订单未支付，无法处理");
        }
        
        try {
            // 更新订单状态
            order.setStatus(OrderStatus.PROCESSING);
            orderRepository.save(order);
            
            // 扣减库存
            inventoryService.reduceStock(order.getItems());
            
            // 发送通知
            notificationService.sendOrderProcessedNotification(order);
            
            // 完成订单
            order.setStatus(OrderStatus.COMPLETED);
            orderRepository.save(order);
            
        } catch (Exception e) {
            // 回滚操作
            rollbackOrder(order);
            throw new RuntimeException("订单处理失败", e);
        }
    }
    
    private void rollbackOrder(Order order) {
        try {
            order.setStatus(OrderStatus.FAILED);
            orderRepository.save(order);
            logger.error("订单处理失败，已回滚: {}", order.getId());
        } catch (Exception e) {
            logger.error("订单回滚失败: {}", order.getId(), e);
        }
    }
}
```

## 异常处理防御

### 分层异常处理
```java
@Service
public class OrderService {
    
    @Transactional
    public void processOrder(Order order) {
        try {
            // 业务逻辑
            validateOrder(order);
            updateInventory(order);
            createPayment(order);
            sendNotification(order);
            
        } catch (ValidationException e) {
            // 业务异常，回滚事务
            logger.error("订单验证失败: {}", order.getId(), e);
            throw e;
        } catch (PaymentException e) {
            // 支付异常，回滚事务
            logger.error("支付处理失败: {}", order.getId(), e);
            throw new BusinessException("支付失败", e);
        } catch (Exception e) {
            // 系统异常，记录日志并回滚
            logger.error("处理订单时发生系统异常: {}", order.getId(), e);
            throw new SystemException("订单处理失败", e);
        }
    }
}
```

### 异常恢复机制
```java
public class RetryableService {
    private static final int MAX_RETRIES = 3;
    private static final long BASE_DELAY_MS = 1000;
    
    public <T> T executeWithRetry(Supplier<T> operation, String operationName) {
        Exception lastException = null;
        
        for (int attempt = 1; attempt <= MAX_RETRIES; attempt++) {
            try {
                return operation.get();
                
            } catch (RetryableException e) {
                lastException = e;
                logger.warn("{}失败，尝试第{}次: {}", operationName, attempt, e.getMessage());
                
                if (attempt < MAX_RETRIES) {
                    long delay = calculateDelay(attempt);
                    try {
                        Thread.sleep(delay);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        throw new RuntimeException("操作被中断", ie);
                    }
                }
                
            } catch (NonRetryableException e) {
                // 不可重试的异常，直接抛出
                throw e;
            }
        }
        
        throw new RuntimeException(operationName + "失败，已重试" + MAX_RETRIES + "次", lastException);
    }
    
    private long calculateDelay(int attempt) {
        // 指数退避
        return BASE_DELAY_MS * (1L << (attempt - 1));
    }
}
```

## 并发安全防御

### 线程安全防御
```java
public class ThreadSafeCounter {
    private final AtomicLong count = new AtomicLong(0);
    private final Object lock = new Object();
    
    public long increment() {
        return count.incrementAndGet();
    }
    
    public long getCount() {
        return count.get();
    }
    
    // 复杂操作的同步
    public void complexOperation() {
        synchronized (lock) {
            // 检查状态
            if (count.get() < 0) {
                throw new IllegalStateException("计数器状态异常");
            }
            
            // 执行复杂操作
            long current = count.get();
            if (current > MAX_VALUE) {
                count.set(0);
            } else {
                count.incrementAndGet();
            }
        }
    }
}
```

### 并发集合防御
```java
public class ConcurrentDataManager {
    private final ConcurrentHashMap<String, AtomicInteger> counters = new ConcurrentHashMap<>();
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    
    public void incrementCounter(String key) {
        // 使用原子操作
        counters.computeIfAbsent(key, k -> new AtomicInteger(0)).incrementAndGet();
    }
    
    public int getCounter(String key) {
        AtomicInteger counter = counters.get(key);
        return counter != null ? counter.get() : 0;
    }
    
    public Map<String, Integer> getAllCounters() {
        lock.readLock().lock();
        try {
            return counters.entrySet().stream()
                .collect(Collectors.toMap(
                    Map.Entry::getKey,
                    entry -> entry.getValue().get()
                ));
        } finally {
            lock.readLock().unlock();
        }
    }
}
```

## 性能防御

### 性能监控防御
```java
@Component
public class PerformanceMonitor {
    private final MeterRegistry meterRegistry;
    
    @EventListener
    public void handleOrderProcessed(OrderProcessedEvent event) {
        Timer.Sample sample = Timer.start(meterRegistry);
        try {
            // 处理订单
            processOrder(event.getOrder());
        } finally {
            sample.stop(Timer.builder("order.processing.time")
                .description("订单处理时间")
                .register(meterRegistry));
        }
    }
    
    @Scheduled(fixedRate = 60000) // 每分钟检查一次
    public void checkSystemHealth() {
        // 检查内存使用
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
        
        double usagePercentage = (double) heapUsage.getUsed() / heapUsage.getMax() * 100;
        
        if (usagePercentage > 90) {
            logger.warn("内存使用率过高: {}%", usagePercentage);
            // 触发垃圾回收
            System.gc();
        }
        
        // 检查线程数
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        int threadCount = threadBean.getThreadCount();
        
        if (threadCount > MAX_THREAD_COUNT) {
            logger.warn("线程数过多: {}", threadCount);
        }
    }
}
```

### 缓存防御
```java
@Service
public class CacheService {
    private final Cache<String, Object> cache;
    private final AtomicLong hitCount = new AtomicLong(0);
    private final AtomicLong missCount = new AtomicLong(0);
    
    public <T> T get(String key, Class<T> type) {
        try {
            Object value = cache.get(key, () -> {
                missCount.incrementAndGet();
                return loadFromDatabase(key);
            });
            
            hitCount.incrementAndGet();
            return type.cast(value);
            
        } catch (ExecutionException e) {
            logger.error("缓存获取失败: {}", key, e);
            return loadFromDatabase(key);
        }
    }
    
    public void put(String key, Object value) {
        try {
            cache.put(key, value);
        } catch (Exception e) {
            logger.warn("缓存存储失败: {}", key, e);
            // 缓存失败不影响主流程
        }
    }
    
    @Scheduled(fixedRate = 300000) // 每5分钟
    public void logCacheStats() {
        long hits = hitCount.get();
        long misses = missCount.get();
        long total = hits + misses;
        
        if (total > 0) {
            double hitRate = (double) hits / total * 100;
            logger.info("缓存命中率: {}% ({}/{})", hitRate, hits, total);
        }
    }
}
```

## 安全防御

### 输入安全防御
```java
public class SecurityUtils {
    
    public static String sanitizeInput(String input) {
        if (input == null) {
            return null;
        }
        
        // 移除潜在的危险字符
        return input.replaceAll("[<>\"'&]", "")
                   .trim();
    }
    
    public static boolean isValidEmail(String email) {
        if (email == null || email.trim().isEmpty()) {
            return false;
        }
        
        // 长度检查
        if (email.length() > 254) {
            return false;
        }
        
        // 格式检查
        String emailRegex = "^[A-Za-z0-9+_.-]+@([A-Za-z0-9.-]+\\.[A-Za-z]{2,})$";
        return email.matches(emailRegex);
    }
    
    public static boolean isValidPassword(String password) {
        if (password == null) {
            return false;
        }
        
        // 长度检查
        if (password.length() < 8 || password.length() > 128) {
            return false;
        }
        
        // 复杂度检查
        boolean hasUpper = password.chars().anyMatch(Character::isUpperCase);
        boolean hasLower = password.chars().anyMatch(Character::isLowerCase);
        boolean hasDigit = password.chars().anyMatch(Character::isDigit);
        boolean hasSpecial = password.chars().anyMatch(ch -> "!@#$%^&*()_+-=[]{}|;:,.<>?".indexOf(ch) >= 0);
        
        return hasUpper && hasLower && hasDigit && hasSpecial;
    }
}
```

### SQL注入防御
```java
@Repository
public class UserRepository {
    
    // ❌ 不安全的写法
    public List<User> findUsersByName(String name) {
        String sql = "SELECT * FROM users WHERE name = '" + name + "'";
        return jdbcTemplate.query(sql, new UserRowMapper());
    }
    
    // ✅ 安全的写法
    public List<User> findUsersByName(String name) {
        // 输入验证
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("用户名不能为空");
        }
        
        // 使用参数化查询
        String sql = "SELECT * FROM users WHERE name = ?";
        return jdbcTemplate.query(sql, new Object[]{name}, new UserRowMapper());
    }
    
    // 使用JPA的安全查询
    @Query("SELECT u FROM User u WHERE u.name = :name")
    List<User> findByName(@Param("name") String name);
}
```

## 实际项目应用

### 完整的服务层防御
```java
@Service
@Transactional
public class OrderService {
    private final OrderRepository orderRepository;
    private final InventoryService inventoryService;
    private final PaymentService paymentService;
    private final NotificationService notificationService;
    
    public Order createOrder(CreateOrderRequest request) {
        // 1. 输入验证
        validateCreateOrderRequest(request);
        
        // 2. 业务规则验证
        validateBusinessRules(request);
        
        try {
            // 3. 创建订单
            Order order = buildOrder(request);
            order = orderRepository.save(order);
            
            // 4. 处理支付
            PaymentResult paymentResult = paymentService.processPayment(order);
            if (!paymentResult.isSuccess()) {
                throw new PaymentException("支付失败: " + paymentResult.getErrorMessage());
            }
            
            // 5. 扣减库存
            inventoryService.reduceStock(order.getItems());
            
            // 6. 发送通知
            notificationService.sendOrderCreatedNotification(order);
            
            return order;
            
        } catch (Exception e) {
            // 7. 异常处理和回滚
            handleOrderCreationFailure(request, e);
            throw e;
        }
    }
    
    private void validateCreateOrderRequest(CreateOrderRequest request) {
        Objects.requireNonNull(request, "订单请求不能为空");
        
        if (request.getCustomerId() == null) {
            throw new ValidationException("客户ID不能为空");
        }
        
        if (request.getItems() == null || request.getItems().isEmpty()) {
            throw new ValidationException("订单必须包含商品");
        }
        
        for (OrderItemRequest item : request.getItems()) {
            if (item.getProductId() == null) {
                throw new ValidationException("商品ID不能为空");
            }
            if (item.getQuantity() == null || item.getQuantity() <= 0) {
                throw new ValidationException("商品数量必须大于0");
            }
        }
    }
    
    private void validateBusinessRules(CreateOrderRequest request) {
        // 检查客户是否存在
        if (!customerService.existsById(request.getCustomerId())) {
            throw new BusinessException("客户不存在");
        }
        
        // 检查商品库存
        for (OrderItemRequest item : request.getItems()) {
            if (!inventoryService.hasStock(item.getProductId(), item.getQuantity())) {
                throw new BusinessException("商品库存不足: " + item.getProductId());
            }
        }
    }
    
    private void handleOrderCreationFailure(CreateOrderRequest request, Exception e) {
        logger.error("订单创建失败: {}", request, e);
        
        // 记录失败原因
        auditService.recordOrderCreationFailure(request, e);
        
        // 发送失败通知
        try {
            notificationService.sendOrderCreationFailureNotification(request, e);
        } catch (Exception notificationException) {
            logger.warn("发送失败通知时发生异常", notificationException);
        }
    }
}
```

### 控制器层防御
```java
@RestController
@RequestMapping("/api/orders")
@Validated
public class OrderController {
    
    @PostMapping
    public ResponseEntity<OrderResponse> createOrder(
            @Valid @RequestBody CreateOrderRequest request,
            HttpServletRequest httpRequest) {
        
        try {
            // 记录请求
            auditService.recordRequest(httpRequest, request);
            
            // 创建订单
            Order order = orderService.createOrder(request);
            
            // 构建响应
            OrderResponse response = OrderResponse.from(order);
            
            return ResponseEntity.ok(response);
            
        } catch (ValidationException e) {
            logger.warn("订单创建验证失败: {}", e.getMessage());
            return ResponseEntity.badRequest()
                .body(OrderResponse.error("验证失败: " + e.getMessage()));
                
        } catch (BusinessException e) {
            logger.warn("订单创建业务失败: {}", e.getMessage());
            return ResponseEntity.unprocessableEntity()
                .body(OrderResponse.error("业务错误: " + e.getMessage()));
                
        } catch (Exception e) {
            logger.error("订单创建系统异常", e);
            return ResponseEntity.internalServerError()
                .body(OrderResponse.error("系统异常，请稍后重试"));
        }
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<OrderResponse> getOrder(@PathVariable Long id) {
        // 参数验证
        if (id == null || id <= 0) {
            return ResponseEntity.badRequest()
                .body(OrderResponse.error("订单ID无效"));
        }
        
        try {
            Optional<Order> order = orderService.findById(id);
            
            if (order.isPresent()) {
                return ResponseEntity.ok(OrderResponse.from(order.get()));
            } else {
                return ResponseEntity.notFound().build();
            }
            
        } catch (Exception e) {
            logger.error("获取订单失败: {}", id, e);
            return ResponseEntity.internalServerError()
                .body(OrderResponse.error("获取订单失败"));
        }
    }
}
```

## 最佳实践总结

### 1. 分层防御策略
- **控制器层**：参数验证、异常处理、响应格式化
- **服务层**：业务规则验证、事务管理、异常转换
- **数据层**：数据完整性检查、SQL注入防护
- **工具层**：通用验证、安全处理、性能监控

### 2. 防御性编程检查清单
- [ ] 所有公共方法都有参数验证
- [ ] 所有外部输入都经过安全处理
- [ ] 所有资源都有正确的生命周期管理
- [ ] 所有异常都有适当的处理策略
- [ ] 所有并发操作都有同步保护
- [ ] 所有性能关键路径都有监控
- [ ] 所有安全敏感操作都有权限检查

### 3. 性能与防御的平衡
```java
// 适度防御，避免过度检查
public String processData(String input) {
    // 必要的检查
    if (input == null) {
        return "";
    }
    
    // 避免过度检查
    // if (input.getClass() != String.class) return ""; // 过度防御
    
    return input.trim();
}
```

## 反模式避免

### ❌ 不好的做法
```java
// 1. 忽略异常
public void processFile(String path) {
    try {
        Files.readAllLines(Paths.get(path));
    } catch (IOException e) {
        // 忽略异常，可能导致静默失败
    }
}

// 2. 过度防御
public void method(Object obj) {
    if (obj == null) return;
    if (obj.getClass() == null) return;
    if (obj.toString() == null) return;
    // 过度检查影响性能
}

// 3. 不明确的错误信息
public void validate(String input) {
    if (input == null) {
        throw new RuntimeException("错误"); // 信息不明确
    }
}
```

### ✅ 好的做法
```java
// 1. 适当的异常处理
public void processFile(String path) {
    try {
        Files.readAllLines(Paths.get(path));
    } catch (IOException e) {
        logger.error("文件处理失败: {}", path, e);
        throw new FileProcessingException("无法处理文件: " + path, e);
    }
}

// 2. 适度防御
public void method(Object obj) {
    Objects.requireNonNull(obj, "对象不能为空");
    // 必要的检查即可
}

// 3. 明确的错误信息
public void validate(String input) {
    if (input == null) {
        throw new IllegalArgumentException("输入字符串不能为空");
    }
}
```

## 总结

防御性编程是一种**预防胜于治疗**的编程理念：

1. **假设最坏情况** - 认为输入可能无效、系统可能出错
2. **早期验证** - 在方法入口进行参数检查
3. **明确错误处理** - 提供清晰的错误信息和处理策略
4. **资源保护** - 确保资源正确释放
5. **状态一致性** - 维护对象和系统的有效状态
6. **性能监控** - 关注系统性能和资源使用
7. **安全防护** - 防止安全漏洞和攻击

通过防御性编程，我们可以编写出更加健壮、可靠和易于维护的代码，这在工业级开发中是非常重要的质量保证手段。

